<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://www.eclipse.org/viatra/">VIATRA</a> is an open source model transformation framework, focusing on efficient evaluation of model queries and supports various transformation workflows. This document contains a tutorial for getting started with the query and transformation development.</p>
</div>
<div class="paragraph">
<p>The tutorial relies on the <a href="../cps/Home.html">CPS Demonstrator application</a>. The CPS Demonstrator is specified to cover a usual workflow in Model-driven Engineering, where a system is (1) first described in a source model, then (2) automated model-to-model transformations are used to derive a target model. Finally, (3) model-to-text transformation is performed to generate code from the target domain. In addition, a model generator that can automatically create source domain models can support the correctness testing and performance evaluation of the components. This tutorial uses only a subset of the transformation problem, as its main goal is to illustrate the basics of the VIATRA environment. Consult the original demonstrator for a more complex transformation example.</p>
</div>
<div class="paragraph">
<p>We expect readers to be familiar with the basics of Eclipse plug-in development, more specifically creating plug-in projects and defining basic UI extensions such as commands. Additionally, we expect a basic understanding of EMF-based modeling. If required, look at the Plug-in development tutorial at <a href="http://www.vogella.com/tutorials/EclipsePlugin/article.html" class="bare">http://www.vogella.com/tutorials/EclipsePlugin/article.html</a> or the EMF tutorial at <a href="http://www.vogella.com/tutorials/EclipseEMF/article.html" class="bare">http://www.vogella.com/tutorials/EclipseEMF/article.html</a> for a short presentation on these subjects.</p>
</div>
<div class="paragraph">
<p>This document starts with a <a href="#environment">quick setup guide</a>, then describes model <a href="#_query_development">query development</a>. Both <a href="#_batch_transformations">batch</a> and <a href="#_event_driven_transformations">event-driven transformations</a> are covered later.</p>
</div>
<div class="paragraph">
<p>This document is intended only as a short tutorial for the usage of the Query and Transformation capabilities of VIATRA. A more detailed documentation is maintained at <a href="http://wiki.eclipse.org/VIATRA" class="bare">http://wiki.eclipse.org/VIATRA</a>.</p>
</div>
<div id="toc" class="toc">
<div id="toctitle" class="title">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#environment">1. Setting up the tutorial</a></li>
<li><a href="#_query_development">2. Query Development</a>
<ul class="sectlevel2">
<li><a href="#_define_your_first_query">2.1. Define your First Query</a></li>
<li><a href="#_evaluate_queries_in_the_query_results_view">2.2. Evaluate Queries in the Query Results View</a></li>
<li><a href="#_define_additional_queries">2.3. Define Additional Queries</a></li>
<li><a href="#_validation">2.4. Validation</a></li>
<li><a href="#_references">2.5. References</a></li>
</ul>
</li>
<li><a href="#_model_transformation_development">3. Model Transformation Development</a>
<ul class="sectlevel2">
<li><a href="#_batch_transformations">3.1. Batch Transformations</a></li>
<li><a href="#_event_driven_transformations">3.2. Event-driven Transformations</a></li>
</ul>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="environment"><a class="link" href="#environment">1. Setting up the tutorial</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial was written for version 1.6 (released on 28th June 2017).</p>
</div>
<div class="paragraph">
<p>Starting with version 1.6 VIATRA is available from the Simultaneous Release Train (Oxygen version); otherwise it can be downloaded from the p2 repository at <a href="http://download.eclipse.org/viatra/updates/release/" class="bare">http://download.eclipse.org/viatra/updates/release/</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/install.png" alt="Install window">
</div>
<div class="title">Figure 1. Install window</div>
</div>
<div class="paragraph">
<p>For a faster installation, you may deselect the <em>Contact all update sites during install...</em> field, but then it might be necessary to install the required <em>Xtext Runtime</em> manually.</p>
</div>
<div class="paragraph">
<p>This tutorial relies on the CPS demonstrator example from <a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps" class="bare">https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps</a> (for a description of the example please consult <a href="https://github.com/viatra/viatra-docs/blob/master/cps/Home.adoc" class="bare">https://github.com/viatra/viatra-docs/blob/master/cps/Home.adoc</a>).</p>
</div>
<div class="paragraph">
<p>This document assumes that the metamodels themselves are installed into the Eclipse instance. They are available from the p2 repository <a href="https://build.incquerylabs.com/jenkins/job/CPS-Demonstrator/lastSuccessfulBuild/artifact/cps/releng/org.eclipse.viatra.examples.cps.update/target/repository/" class="bare">https://build.incquerylabs.com/jenkins/job/CPS-Demonstrator/lastSuccessfulBuild/artifact/cps/releng/org.eclipse.viatra.examples.cps.update/target/repository/</a></p>
</div>
<div class="paragraph">
<p>VIATRA defines a custom perspective called <code>Transformation Development</code> that includes a few views and shortcuts that make it easier to develop queries and transformations. The remainder of the tutorial expects that this perspective is selected; in case a different perspective is used, the corresponding views and wizards are still available in their standard respective locations.</p>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="_query_development"><a class="link" href="#_query_development">2. Query Development</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Constraints and conditions in the VIATRA framework are expressed using a graph pattern-based language. This declarative formalism allows very compact definitions of complex conditions, while it is still possible to provide live query evaluation based on the Rete algorithm.</p>
</div>
<div class="paragraph">
<p>In the following we get an overview of the query development environment, starting with the definition of queries, followed by query evaluation support. Then we gain an understanding of the various language elements by creating more and more complex queries.</p>
</div>
<div class="paragraph">
<p>A graph pattern encodes a <em>named</em> query with some <em>parameters</em> defined as a <em>disjunction</em> of pattern <em>bodies</em>, while each body consists of a <em>set</em> of constraints.  The result of a graph pattern, called <em>match set</em>, is a <em>set</em> of (model element) tuples where the elements fulfill all constraints defined in at least one of the pattern bodies.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The pattern language always works on sets: neither the constraints nor the match set is ordered; and match set includes never includes multiple tuples with exactly the same model elements.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_define_your_first_query"><a class="link" href="#_define_your_first_query">2.1. Define your First Query</a></h3>
<div class="paragraph">
<p>To define queries, first a  <em>VIATRA Query Project</em> has to be created with the standard <em>New Project Wizard</em> of Eclipse. Such projects are specialized Eclipse plug-in projects with preconfigured VIATRA dependencies and the query generator initialized. Query specifications have to be added to the Java classpath of the projects, more specifically into Java packages. Based on these observations the creation of the first query consists of the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a new VIATRA Query project in the host Eclipse with the following name: <code>org.eclipse.viatra.examples.cps.queries</code>.</p>
</li>
<li>
<p>Add <code>org.eclipse.viatra.examples.cps.model</code> to the Plug-in dependencies</p>
</li>
<li>
<p>Create a new query definition in a package named <code>org.eclipse.viatra.examples.cps.queries</code> and a file named <code>queries.vql</code>. In the wizard create an empty query. Fill the first query:</p>
<div id="app-listing" class="listingblock">
<div class="title">queries.vql</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">// Java package declaration, must match the container of the file
package org.eclipse.viatra.examples.cps.queries

// EPackage import
import "http://org.eclipse.viatra/model/cps"

// Pattern declaration
pattern hostIpAddress(host: HostInstance, ip : java String) {
    // Type constraint stating that variables 'host' and 'ip' are connected via a 'nodeIp' attribute
    HostInstance.nodeIp(host,ip);
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Looking at the pattern header, we see that this pattern has two parameters, meaning its results will be a pair of values, the first selecting a <code>HostInstance</code> from the model, while the second one a <code>String</code> literal. The connection between these elements is described by a single constraint ensuring that <code>ip</code> variable stores the <code>nodeIp</code> attribute of a corresponding <code>HostInstance</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_evaluate_queries_in_the_query_results_view"><a class="link" href="#_evaluate_queries_in_the_query_results_view">2.2. Evaluate Queries in the Query Results View</a></h3>
<div class="paragraph">
<p>VIATRA includes a view to evaluate the results of queries over various editors, and reacts on changes in the editor.</p>
</div>
<div class="paragraph">
<p>The <strong>Query Results</strong> view is the primary tool for debugging graph patterns. Open the view by selecting <em>Window/Show View/Query Results</em> or you can simply press the <span class="keyseq"><kbd>CTRL</kbd>+<kbd>3</kbd></span> shortcut and start to type the name of the view. The view allows loading models and queries, and display (and update) the results of queries automatically.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Import instances project <code><code>models\org.eclipse.viatra.examples.cps.instances</code></code> from the <a href="https://git.eclipse.org/c/viatra/org.eclipse.viatra.examples.git/tree/cps/">CPS Git repository</a>. Note that this is <strong>not</strong> a Git repository URL, but a web interface; a repository url can be found in the bottom of the page.</p>
</li>
<li>
<p>Open our example instance model (/org.eclipse.viatra.examples.cps.instances/example.cyberphysicalsystem)</p>
</li>
<li>
<p>Make sure "ReteEngine" is selected in the toolbar of the Query Results view</p>
</li>
<li>
<p>then press the 'Load model from active editor' (first button on the toolbar)</p>
</li>
<li>
<p>Open the query specification (vql file)</p>
</li>
<li>
<p>then press the 'Load queries from the active editor' button</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>At this point the <em>Query Results</em> view should contain the matches of the freshly created pattern. Using the example model, you can see that there are 6 matches for the pattern, each consisting of a HostInstance-IP address pair. Note that the <em>Query Results</em> view provides live results: by updating the model in the model editor file, e.g. adding a new host instance or changing its IP address, the results update automatically.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/queryresultview.png" alt="Query Results View in Action">
</div>
<div class="title">Figure 2. Query Results View</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the 'Load model from active editor' button is not enabled, it either means, the current editor does not contain a model, or VIATRA does not understand the editor type. By default, EMF tree editors are supported; other editor types, such as graphical editors are supported by additional integration plug-ins, such as the GMF or Graphiti integration available from the VIATRA repository.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_define_additional_queries"><a class="link" href="#_define_additional_queries">2.3. Define Additional Queries</a></h3>
<div class="paragraph">
<p>In the following, we define a set of patterns that illustrate additional capabilities of the query language. Each pattern will come with a short definition, followed by the code itself and some remarks about how the pattern works.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>List all <code>HostInstance</code> elements whose IP address is an empty string</p>
<div class="ulist">
<ul>
<li>
<p>This pattern, similar to the first pattern, still consists of a single constraint. The pattern constraints can refer to Java literals, like empty strings or numbers directly. This pattern should have no matches in the example model, as by default all instances have a non-empty IP address set up.</p>
</li>
<li>
<p>Notice that if you create a new <code>HostInstance</code> element, it will not appear in the match results. This happens because in EMF unset an empty attributes are different. You can write a pattern that finds missing attribute values using the <code>neg find</code> construct (see later).</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern emptyIpAddress(host: HostInstance) {
    HostInstance.nodeIp(host, "");
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List are <code>HostInstance</code>-<code>HostInstance</code> pairs that share a common IP address</p>
<div class="ulist">
<ul>
<li>
<p>This pattern is more complex, as it has three parameters and three constraints. The first two describe similar type constraints we have seen. The pattern also compares the values of variables <code>host1</code> and <code>host2</code> with each other using the <code>!=</code> (<em>not equal</em>) operator (The <code>==</code> operator is also available).</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern sameIpAddress(host1 : HostInstance, host2 : HostInstance, commonIp : java String) {
    HostInstance.nodeIp(host1, commonIp);
    HostInstance.nodeIp(host2, commonIp);
    host1!=host2;
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List all <code>HostInstance</code> elements that have non well-formed IPv4 addresses (e.g. not four numbers separated with dots)</p>
<div class="ulist">
<ul>
<li>
<p>The well-formedness validation of the IP address strings requires specific validation blocks called <code>check</code> expressions where  you can write a wide range of <em>Xbase</em> expressions, behaaving similarly to Java and accessing Java classes from the classpath of the project. In this case, the well-formedness of the address values are inde.</p>
</li>
<li>
<p>It is important to note that check expressions <strong>have to</strong> be side-effect free and can only be called on attribute variables.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern ipFormatInvalid(host : HostInstance, ip : java String) {
    HostInstance.nodeIp(host,ip);
    check (
        !ip.matches("^[\\d\\.]+")
    );
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List <code>State</code> elements connected through <code>Transition</code> elements</p>
<div class="ulist">
<ul>
<li>
<p>A pattern body might use variables other than the pattern parameters, such as the variable <code>transition</code> in this example. These variables are called local variables.</p>
</li>
<li>
<p>It is important to note that if there are multiple transitions between two states, the match set will still include only a single pair of the states, because local variables are not included in the match tuples. If all edges are required, the corresponding transition variable should also be declared as a parameter.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern connectedTo(state: State, other: State){
    // There exists a transition from `state` to `other`
    State.outgoingTransitions(state, transition);
    Transition.targetState(transition, other);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List bad host instances that fail either of the previous conditions.</p>
<div class="ulist">
<ul>
<li>
<p>Disjunctions can be expressed by using the <code>or</code> keyword between pattern bodies. A model element tuple is included in the match set of a pattern, if at least one of the bodies have a match. Note that if multiple bodies would match the same tuple, the match set of the pattern will still only include the tuple once (<em>set semantics</em>).</p>
</li>
<li>
<p>Patterns can be reused using <code>find</code> constraints meaning all conditions expressed by the called pattern must be matched from the source.</p>
</li>
<li>
<p>This pattern also includes <em>single-use</em> (or don&#8217;t care) variables, starting with the character '_'. Such a declaration describes a variable where we are only interested in its existence but not its value.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern badHost(host : HostInstance, ip : java String) {
    find sameIpAddress(host, _other, ip);
} or {
    HostInstance.nodeIp(host, ip);
    find emptyIpAddress(host);
} or {
    HostInstance.nodeIp(host, ip);
    find ipFormatInvalid(host);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List all good host instances (that meet neither of the incorrect conditions)</p>
<div class="ulist">
<ul>
<li>
<p>The negative pattern composition, expressed by the <code>neg find</code> keyword is used to define negative conditions. This works similar to the <code>find</code> constraints, with the notable exception that if there are any matches to the badHost with the selected parameters, the host pattern fails to match.</p>
</li>
<li>
<p>Those actual parameters of the negative pattern call that are not used elsewhere in the calling body are <em>universally quantified</em>, meaning that the calling pattern only matches if variables of the calling pattern cannot be bound to matching elements.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern goodHost(host : HostInstance, ip : java String) {
    HostInstance.nodeIp(host, ip);
    neg find badHost(host, _);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List the number of applications for each HostInstance</p>
<div class="ulist">
<ul>
<li>
<p>Patterns can be marked as private, making the pattern itself only visible inside the source file it is defined. The generated code for these patterns is reduced (e.g. does not include generated Match and Matcher classes for easier access).</p>
</li>
<li>
<p>It is possible to calculate the matches of a pattern using the <code>count find</code> expressions. The value of such an expression is the number of matches found with the selected number of matches.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">private pattern applications(host, app) {
    HostInstance.applications(host, app);
}

pattern countApplications(host : HostInstance, M) {
    M == count find applications(host, _);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>List all states of a state machine that are reachable from its initial state (either directly or indirectly)</p>
<div class="ulist">
<ul>
<li>
<p>The reachable states are calculated using the transitive closure of the previously introduced connectedTo pattern.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">pattern reachableState(sm :StateMachine, state: State){
    // The initial state of the statemachine is reachable
    StateMachine.initial(sm, state);
} or {
    StateMachine.initial(sm, initial);
    StateMachine.states(sm, state);
    // The + symbol after the pattern name represents transitive closure
    find connectedTo+(initial, state);
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_validation"><a class="link" href="#_validation">2.4. Validation</a></h3>
<div class="paragraph">
<p>VIATRA provides facilities to create validation rules based on the pattern language of the framework. These rules can be evaluated on various EMF instance models and upon violations of constraints, markers are automatically created in the Eclipse Problems View.</p>
</div>
<div class="paragraph">
<p>The <strong>@Constraint</strong> annotation can be used to mark a pattern as a validation rule. If the framework finds at least one pattern with such annotation.</p>
</div>
<div class="paragraph">
<p>Annotation parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>key:</em> The list of paremeters which determine which objects the constraint violation needs to be attached to.</p>
</li>
<li>
<p><em>message:</em> The message to display when the constraint violation is found. The message may refer the parameter variables between $ symbols, or their EMF features, such as in $Param1.name$.</p>
</li>
<li>
<p><em>severity:</em> "warning" or "error"</p>
</li>
<li>
<p><em>targetEditorId:</em> An Eclipse editor ID where the validation framework should register itself to the context menu. Use "*" as a wildcard if the constraint should be used always when validation is started.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To find a specific editor id, we can use the <em>Plug-in Selection Spy</em> tool with a <span class="keyseq"><kbd>Shift</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> shortcut.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">@Constraint(targetEditorId = "org.eclipse.viatra.examples.cps.cyberPhysicalSystem.presentation.CyberPhysicalSystemEditorID",
            severity = "error",
            message = "The ip address is not unique",
            key = {"host1"})
pattern sameIpAddress(host1: HostInstance, host2: HostInstance, commonIp) {
    HostInstance.nodeIp(host1, commonIp);
    HostInstance.nodeIp(host2, commonIp);
    host1!=host2;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_references"><a class="link" href="#_references">2.5. References</a></h3>
<div class="ulist">
<ul>
<li>
<p>Pattern Language: <a href="https://wiki.eclipse.org/VIATRA/Query/UserDocumentation/QueryLanguage" class="bare">https://wiki.eclipse.org/VIATRA/Query/UserDocumentation/QueryLanguage</a></p>
</li>
<li>
<p>Validation Framework: <a href="https://wiki.eclipse.org/VIATRA/Addons/UserDocumentation/Validation" class="bare">https://wiki.eclipse.org/VIATRA/Addons/UserDocumentation/Validation</a></p>
</li>
<li>
<p>Query Based Features: <a href="https://wiki.eclipse.org/VIATRA/Addons/UserDocumentation/Query_Based_Features" class="bare">https://wiki.eclipse.org/VIATRA/Addons/UserDocumentation/Query_Based_Features</a></p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_model_transformation_development"><a class="link" href="#_model_transformation_development">3. Model Transformation Development</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>For model transformation development a Java API is available, allowing seamless integration of the transformations into any Java applications. However, to enhance readability, we recommend using a higher-level JVM language, as it allows defining the transformation as an internal DSL of this host language.</p>
</div>
<div class="paragraph">
<p>In this tutorial we rely on the <a href="https://eclipse.org/xtend/">Xtend language</a> to host the VIATRA transformation DSL, and we rely on its extension method and type inference support to reduce unnecessary elements. However, other JVM-based languages can also be used with similar efficiency (for an example in <a href="https://kotlinlang.org/">Kotlin</a> see <a href="https://gist.github.com/doczir/bfe95c470599c5b8e60b400b80f92ea2" class="bare">https://gist.github.com/doczir/bfe95c470599c5b8e60b400b80f92ea2</a>).</p>
</div>
<div class="sect2">
<h3 id="_batch_transformations"><a class="link" href="#_batch_transformations">3.1. Batch Transformations</a></h3>
<div class="paragraph">
<p>This exercise helps the audience to create a simple batch transformation using the VIATRA Transformation API.
The transformation will transform the hosts and applications in a CPS model to a deployment model.
The exercise also covers registering a menu command which initializes the transformation.</p>
</div>
<div class="sect3">
<h4 id="_create_transformation"><a class="link" href="#_create_transformation">3.1.1. Create transformation</a></h4>
<div class="paragraph">
<p>For the transformation, we have to created a <em>VIATRA Query Project</em> (the one from the <a href="#_query_development">query development tutorial</a> could also be reused), and create a new query file called <em>CpsXformM2M.vql</em> to store the patterns we want to use in the transformation with the following contents:</p>
</div>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">import "http://org.eclipse.viatra/model/cps"
import "http://org.eclipse.viatra/model/deployment"
import "http://org.eclipse.viatra/model/cps-traceability"

pattern hostInstance(hostInstance : HostInstance) {
    HostInstance(hostInstance);
}

pattern applicationInstance(
    appType : ApplicationType,
    appInstance : ApplicationInstance
) {
    HostInstance.applications(_, appInstance);
    ApplicationType.instances(appType, appInstance);
}

/**
 * Traceability link access
 */
pattern cps2depTrace(
    cps2dep : CPSToDeployment,
    trace : CPS2DeploymentTrace,
    cpsElement : Identifiable,
    depElement : DeploymentElement
) {
    CPSToDeployment.traces(cps2dep, trace);
    CPS2DeploymentTrace.cpsElements(trace, cpsElement);
    CPS2DeploymentTrace.deploymentElements(trace, depElement);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Create transformation class in Xtend</p>
<div class="ulist">
<ul>
<li>
<p>Create new <em>Model Transformation</em> with the wizard</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/transformation_wizard.png" alt="transformation wizard">
</div>
<div class="title">Figure 3. Model Transformation Wizard - Create new transformation</div>
</div>
</li>
<li>
<p>Setup the name of the transformation and click Next</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/batch_transformation_wizard_name.png" alt="batch transformation wizard name">
</div>
<div class="title">Figure 4. Model Transformation Wizard - Name of the new batch transformation</div>
</div>
</li>
<li>
<p>Setup the type of the transformation to <em>BatchTransformation</em> and click Finish</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/batch_transformation_wizard_type.png" alt="batch transformation wizard type">
</div>
<div class="title">Figure 5. Model Transformation Wizard - Type of the new transformation</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the created file we have to register a few extension methods, more specifically for our used queries (<code><code>CpsXformM2m</code></code>, the same name the VQL file uses) and the EMF EPackages we want to refer (here the deployment and traceability packages). A few additional extension methods are already registered, e.g. transformation rule builder and model manipulation API.</p>
</div>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">/** VIATRA Query Pattern group **/
val extension CpsXformM2M cpsXformM2M = CpsXformM2M.instance

/** EMF metamodels **/
val extension DeploymentPackage depPackage = DeploymentPackage.eINSTANCE
val extension TraceabilityPackage trPackage = TraceabilityPackage.eINSTANCE</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Constructor will also initialize transformation (replace the generated one)</p>
<div class="ulist">
<ul>
<li>
<p>It assumes that the resource and trace models are already created</p>
</li>
<li>
<p>The IModelManipulations implementation is used to make model access replaceable, this way the same transformation may be used for cases where the resource set is transactional. The initialization of this is generated automatically into the <code>createTransformation</code> method.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val CPSToDeployment cps2dep

new(CPSToDeployment cps2dep, ViatraQueryEngine engine) {
    this.cps2dep = cps2dep
    resource = cps2dep.deployment.eResource
    this.engine = engine
    prepare(engine)
    createTransformation
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation will remain active until disposed is called (there is a generated <code>dispose</code> method in the class)</p>
</li>
<li>
<p>Create a rule to generate DeploymentHosts for each HostInstances</p>
<div class="ulist">
<ul>
<li>
<p>The <code>BatchTransformationRuleFactory</code> extension provides a builder API for rule definition</p>
</li>
<li>
<p>A VIATRA query is used as precondition to the rule, which means the rule will be activated each time the given pattern when changes allowing to update the output accordingly.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val hostRule = createRule.precondition(HostInstanceMatcher.querySpecification).action[/*Action part*/].build</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Specify which action to run when the rule fires. It will create the transformed <code>DeploymentHost</code> element in the output model as well as a trace element associating the source <code>HostInstance</code> and the target <code>DeploymentHost</code>:</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val hostRule = createRule.precondition(HostInstanceMatcher.querySpecification).action[
    val cpsHostInstance = it.hostInstance
    val nodeIp = cpsHostInstance.nodeIp
    println('''Mapping host with IP: «nodeIp»''')

    /** Create &amp; initialize DeploymentHost in output model **/
    val depHost = cps2dep.deployment.createChild(deployment_Hosts, deploymentHost) =&gt; [
        set(deploymentHost_Ip, nodeIp)
    ]

    /** Create trace element in trace model **/
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, cpsHostInstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, depHost)
    ]

    println('''Mapped with IP: «nodeIp»''')
].build</code></pre>
</div>
</div>
</li>
<li>
<p>The rule which creates <code>DeploymentApplication</code> elements for <code>ApplicationInstance</code> objects, looks similar. It has to find the <code>DeploymentHost</code> created from the <code>HostInstance</code> to which the source <code>ApplicationInstance</code> is allocated, so it assumes the <code>hostRule</code> has already fired:</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val applicationRule = createRule.precondition(ApplicationInstanceMatcher.querySpecification).action[
    val cpsApplicationInstance = it.appInstance
    val appId = cpsApplicationInstance.identifier
    println('''Mapping application with ID: «appId»''')

    /* Find the DeploymentHost created from the HostInstance to which the source ApplicationInstance is allocated */
    val cpsHostInstance = cpsApplicationInstance.allocatedTo
    val depHost = engine.cps2depTrace.getAllValuesOfdepElement(null, null, cpsHostInstance).filter(DeploymentHost).head
    /* Create &amp; initialize DeploymentApplication in this DeploymentHost */
    val deploymentApplication = depHost.createChild(deploymentHost_Applications, deploymentApplication) =&gt; [
        set(deploymentApplication_Id, appId)
    ]

    /* Create trace element in trace model */
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, cpsApplicationInstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, deploymentApplication)
    ]

    println('''Mapped application with ID: «appId»''')
].build</code></pre>
</div>
</div>
</li>
<li>
<p>Implement the method which performs the transformation using the rules defined above:</p>
<div class="ulist">
<ul>
<li>
<p>Since we are using the non-incremental (the whole model is always retransformed on model changes), the output and trace models are to be cleared before the any rule can fire</p>
</li>
<li>
<p>Pay attention to fire the rules in the proper order</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">def execute() {
    println('''Executing transformation on: Cyber-physical system: «cps2dep.cps.identifier»''')
    /* Clear output &amp; trace model for batch transformation**/
    cps2dep.deployment.hosts.clear
    cps2dep.traces.clear
    /* Fire transformation rules**/
    hostRule.fireAllCurrent
    applicationRule.fireAllCurrent
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_create_a_menu_command_to_execute_the_transformation"><a class="link" href="#_create_a_menu_command_to_execute_the_transformation">3.1.2. Create a menu command to execute the transformation</a></h4>
<div class="ulist">
<ul>
<li>
<p>Create a UI plugin with the following additional dependencies:</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">org.eclipse.ui,
com.incquerylabs.course.cps.viatra.batch;bundle-version="0.1.0",
org.eclipse.viatra.examples.cps.traceability;bundle-version="0.1.0",
org.eclipse.viatra.query.runtime;bundle-version="1.2.0"</code></pre>
</div>
</div>
</li>
<li>
<p>Create handler implementation:</p>
<div id="app-listing" class="listingblock">
<div class="title">TransformHandler.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class TransformHandler extends AbstractHandler implements IHandler {

    ViatraQueryEngine engine;
    CPS2DeploymentTransformationViatra transformation;

    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        IStructuredSelection selection =
            (IStructuredSelection) HandlerUtil.getCurrentSelection(event);

        CPSToDeployment tracemodel =
            (CPSToDeployment) selection.getFirstElement();

        if (engine == null){
            try {
                engine = ViatraQueryEngine.on(
                            new EMFScope(
                                tracemodel.eResource().getResourceSet()));
                transformation = new CPS2DeploymentTransformationViatra(tracemodel,
                                                                engine);
            } catch (ViatraQueryException e) {
                throw new ExecutionException(e.getMessage(), e);
            }
        }
        transformation.execute();

        return null;
    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>Register handler in the context menu of <code>CPSToDeployment</code> elements in <code>plugin.xml</code>:</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;extension point="org.eclipse.ui.commands"&gt;
    &lt;command
        defaultHandler="com.incquerylabs.course.cps.viatra.batch.ui.TransformHandler"
        id="com.incquerylabs.course.cps.viatra.batch.ui.command"
        name="Transform"&gt;
    &lt;/command&gt;
&lt;/extension&gt;
&lt;extension point="org.eclipse.ui.menus"&gt;
    &lt;menuContribution allPopups="false"
            locationURI="popup:org.eclipse.ui.popup.any?after=additions"&gt;
        &lt;command commandId="com.incquerylabs.course.cps.viatra.batch.ui.command"
                style="push"&gt;
            &lt;visibleWhen checkEnabled="false"&gt;
                &lt;with variable="selection"&gt;
                    &lt;count value="1"&gt;
                    &lt;/count&gt;
                    &lt;iterate&gt;
                        &lt;adapt type="org.eclipse.viatra.examples.cps.traceability.CPSToDeployment"&gt;
                        &lt;/adapt&gt;
                    &lt;/iterate&gt;
                &lt;/with&gt;
            &lt;/visibleWhen&gt;
        &lt;/command&gt;
    &lt;/menuContribution&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_execute_the_transformation"><a class="link" href="#_execute_the_transformation">3.1.3. Execute the transformation</a></h4>
<div class="ulist">
<ul>
<li>
<p>Launch <em>Eclipse Application</em></p>
</li>
<li>
<p>Create a generic resource project</p>
</li>
<li>
<p>Copy a <code>.cyberphysicalsystem</code> resource in it if you already have one, or create a new <em>CaberPhysicalSystem Model</em></p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example1.png" alt="viatraIncr example1">
</div>
<div class="title">Figure 6. Project with a .cyberphysicalsystem resource</div>
</div>
</li>
<li>
<p>Create a Deployment model</p>
<div class="ulist">
<ul>
<li>
<p>Root element shall be <em>Deployment</em></p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example2.png" alt="viatraIncr example2">
</div>
<div class="title">Figure 7. New Deployment Model</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Create a Traceability model</p>
<div class="ulist">
<ul>
<li>
<p>Root element shall be <em>CPS To Deployment</em></p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example3.png" alt="viatraIncr example3">
</div>
<div class="title">Figure 8. New Traceability Model</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>In the Traceability editor, load both CPS and Deployment models with <em>Load Resources...</em> in the context menu</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example4.png" alt="viatraIncr example4">
</div>
<div class="title">Figure 9. Load necessary resources into the Tracebility Model</div>
</div>
</li>
<li>
<p>Set CPS and Deployment references of traceability model in the properties view</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example5.png" alt="viatraIncr example5">
</div>
<div class="title">Figure 10. Set the references of the Traceability Model</div>
</div>
</li>
<li>
<p>Create a new <em>HostType</em>, <em>HostInstance</em>, <em>ApplicationType</em> and <em>ApplicationInstance</em> in the Deployment model</p>
</li>
<li>
<p>Execute transformation using the created command (on the context menu of the Traceability model root)</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatrabatch.png" alt="viatrabatch">
</div>
<div class="title">Figure 11. Transformation command in the context menu</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references_2"><a class="link" href="#_references_2">3.1.4. References</a></h4>
<div class="ulist">
<ul>
<li>
<p>VIATRA Transformation API: <a href="https://wiki.eclipse.org/VIATRA/Transformation/Transformation_API" class="bare">https://wiki.eclipse.org/VIATRA/Transformation/Transformation_API</a></p>
</li>
<li>
<p>Further transformation examples: <a href="https://wiki.eclipse.org/VIATRA/Transformation/Examples" class="bare">https://wiki.eclipse.org/VIATRA/Transformation/Examples</a></p>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect2">
<h3 id="_event_driven_transformations"><a class="link" href="#_event_driven_transformations">3.2. Event-driven Transformations</a></h3>
<div class="paragraph">
<p>This exercise heps the audience to create a simple event-driven transformation using the VIATRA Transformation API. The transformation will create (and then incrementally update while active) a deployment model based on a CPS model. The exercise also covers registering a menu command which initializes the transformation.</p>
</div>
<div class="paragraph">
<p>Given the batch and event-driven transformations are really similar, this section focuses mainly on the differences; if required, consult the <a href="#_batch_transformations">batch transformation tutorial</a>.</p>
</div>
<div class="sect3">
<h4 id="_create_transformation_2"><a class="link" href="#_create_transformation_2">3.2.1. Create transformation</a></h4>
<div class="paragraph">
<p>Specific patterns have to be defined for event-driven rules; note that there are small differences to the batch definitions, e.g. there is an additional pattern called <em>allocatedDeploymentApplication</em>.</p>
</div>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-vql" data-lang="vql">import "http://org.eclipse.viatra/model/cps"
import "http://org.eclipse.viatra/model/deployment"
import "http://org.eclipse.viatra/model/cps-traceability"

pattern hostInstance(hostInstance) {
    HostInstance(hostInstance);
}

pattern applicationInstance(appType, appInstance){
    HostInstance.applications(_, appInstance);
    ApplicationType.instances(appType, appInstance);
}

pattern allocatedDeploymentApplication(depHost, depApp) {
    DeploymentHost.applications(depHost, depApp);
}

pattern cps2depTrace(cps2dep, trace, cpsElement, depElement) {
    CPSToDeployment.traces(cps2dep, trace);
    CPS2DeploymentTrace.cpsElements(trace, cpsElement);
    CPS2DeploymentTrace.deploymentElements(trace, depElement);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Create transformation class (preferably Xtend)</p>
<div class="ulist">
<ul>
<li>
<p>Create new <em>Model Transformation</em> with the wizard</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/transformation_wizard.png" alt="transformation wizard">
</div>
<div class="title">Figure 12. Model Transformation Wizard - Create new transformation</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Setup the name of the transformation and click Next</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/eventdriven_transformation_wizard_name.png" alt="eventdriven transformation wizard name">
</div>
<div class="title">Figure 13. Model Transformation Wizard - Name of the new batch transformation</div>
</div>
</li>
<li>
<p>Setup the type of the transformation to <em>BatchTransformation</em> and click Finish</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/eventdriven_transformation_wizard_type.png" alt="eventdriven transformation wizard type">
</div>
<div class="title">Figure 14. Model Transformation Wizard - Type of the new transformation</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Register used, domain-specific APIs as extensions, common APIs are already generated</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">/*
 * VIATRA Query group
 */
val extension CpsXformM2M cpsXformM2M = CpsXformM2M.instance

/*
 * EMF metamodels
 */
val extension DeploymentPackage depPackage = DeploymentPackage::eINSTANCE
val extension TraceabilityPackage trPackage = TraceabilityPackage::eINSTANCE</code></pre>
</div>
</div>
</li>
<li>
<p>Constructor will also initialize transformation (replace the generated one)</p>
<div class="ulist">
<ul>
<li>
<p>It assumes that the output and trace models are already created</p>
</li>
<li>
<p>The IModelManipulations implementation is used to make model access replaceable, this way the same transformation may be used for cases where the resource set is transactional</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val CPSToDeployment cps2dep

new(CPSToDeployment cps2dep, ViatraQueryEngine engine) {
    this.cps2dep = cps2dep
    this.resource = cps2dep.deployment.eResource
    this.engine = engine
    prepare(engine)
    createTransformation
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Transformation will remain active until dispose is called (a <code>dispose</code> method is already generated)</p>
</li>
<li>
<p>Create a rule to create DeploymentHosts for each HostInstances</p>
<div class="ulist">
<ul>
<li>
<p>The EventDrivenTransformationRuleFactory extension provides a builder API for rule definition</p>
</li>
<li>
<p>A VIATRA query pattern is used as precondition to the rule, which means the rule will be activated each time the given pattern changes allowing to update the output accordingly.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val hostRule = createRule.precondition(HostInstanceMatcher.querySpecification)</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Add action for each kind of changes in the pattern to update trace and output models:</p>
<div class="ulist">
<ul>
<li>
<p>upon creation of a HostInstance</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">.action(CRUDActivationStateEnum.CREATED) [
    val hostinstance = hostInstance
    val nodeIp = hostInstance.nodeIp
    println('''Mapping host with IP: «nodeIp»''')
    /* Create new DeploymentHost element in output model */
    val host = cps2dep.deployment.createChild(deployment_Hosts, deploymentHost) =&gt; [
        set(deploymentHost_Ip, nodeIp)
    ]
    /* Create trace entry */
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, hostinstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, host)
    ]
]</code></pre>
</div>
</div>
</li>
<li>
<p>upon the change of a HostInstance</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">.action(CRUDActivationStateEnum.UPDATED) [
    /* find associated DeploymentHost element */
    val depHost = engine.cps2depTrace
                        .getOneArbitraryMatch(cps2dep, null, hostInstance, null)
                        .depElement as DeploymentHost
    val hostIp = depHost.ip
    println('''Updating mapped host with IP: «hostIp»''')
    /* update IP attribute */
    val nodeIp = hostInstance.nodeIp
    depHost.set(deploymentHost_Ip, nodeIp)
    println('''Updated mapped host with IP: «nodeIp»''')
]</code></pre>
</div>
</div>
</li>
<li>
<p>upon the removal of a HostInstance</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">.action(CRUDActivationStateEnum.DELETED) [
    /* Find trace element */
    val traceMatch = engine.cps2depTrace
                        .getOneArbitraryMatch(cps2dep, null, hostInstance, null)
    val hostIp = hostInstance.nodeIp
    println('''Removing host with IP: «hostIp»''')
    /* Remove DeploymentHost element */
    cps2dep.deployment.remove(deployment_Hosts, traceMatch.depElement)
    /* Remove trace */
    cps2dep.remove(CPSToDeployment_Traces, traceMatch.trace)
    println('''Removed host with IP: «hostIp»''')
]</code></pre>
</div>
</div>
</li>
<li>
<p>Add default activation lifecycle then build the rule:</p>
<div class="ulist">
<ul>
<li>
<p>The lifecycle defines the state machine used to determine the possible states on which transition actions can defined.</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">.addLifeCycle(Lifecycles.getDefault(true, true)).build</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The rule which create DeploymentApplication elements for ApplicationInstances, looks similar</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">val applicationRule = createRule.precondition(ApplicationInstanceMatcher.querySpecification)
.action(CRUDActivationStateEnum.CREATED) [
    /* Find associated DeploymentHost for the HostInstance this application is allocated to */
    val depHost = engine.cps2depTrace.getAllValuesOfdepElement(null, null, appInstance.allocatedTo).filter(
        DeploymentHost).head
    val appinstance = appInstance
    val appId = appInstance.identifier
    println('''Mapping application with ID: «appId»''')
    /* Create DeploymentApplication application in host */
    val app = depHost.createChild(deploymentHost_Applications, deploymentApplication) =&gt; [
        set(deploymentApplication_Id, appId)
    ]
    /* create trace entry */
    cps2dep.createChild(CPSToDeployment_Traces, CPS2DeploymentTrace) =&gt; [
        addTo(CPS2DeploymentTrace_CpsElements, appinstance)
        addTo(CPS2DeploymentTrace_DeploymentElements, app)
    ]
    println('''Mapped application with ID: «appId»''')
].action(CRUDActivationStateEnum.UPDATED) [
    /* find associated DeploymentApplication */
    val depApp = engine.cps2depTrace.getOneArbitraryMatch(cps2dep, null, appInstance, null).
        depElement as DeploymentApplication
    /* Update ID */
    if (depApp.id != appInstance.identifier)
        depApp.set(deploymentApplication_Id, appInstance.identifier)
].action(CRUDActivationStateEnum.DELETED) [
    /* find associated DeploymentApplication */
    val trace = engine.cps2depTrace.getAllValuesOftrace(null, appInstance, null).head as CPS2DeploymentTrace
    val depApp = trace.deploymentElements.head as DeploymentApplication
    /* Remove application from host */
    engine.allocatedDeploymentApplication.getAllValuesOfdepHost(depApp).head.remove(deploymentHost_Applications, depApp)
    /* Remove traces */
    cps2dep.remove(CPSToDeployment_Traces, trace)
].addLifeCycle(Lifecycles.getDefault(true, true)).build</code></pre>
</div>
</div>
</li>
<li>
<p>Replace the generated <code>createTransformation</code> using the rules defined above</p>
<div class="ulist">
<ul>
<li>
<p>For cases when it is possible to have more than one rules activated (e.g. a new HostInstance is added to the model with already set allocated applications) a conflict resolver is used to provide a fixed ordering of rules to be executed.</p>
</li>
<li>
<p>We use a priority-based resolver (lower priority rules will be executed first), which considers priority of disappearing rules to be inverted (a disappearing application&#8217;s priority will be -2)</p>
<div id="app-listing" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">private def createTransformation() {
    //Initialize model manipulation API
    this.manipulation = new SimpleModelManipulations(engine)

    //Initialize event-driven transformation
    val fixedPriorityResolver = new InvertedDisappearancePriorityConflictResolver
    fixedPriorityResolver.setPriority(hostRule.ruleSpecification, 1)
    fixedPriorityResolver.setPriority(applicationRule.ruleSpecification, 2)

    transformation = EventDrivenTransformation.forEngine(engine)
        .setConflictResolver(fixedPriorityResolver)
        .addRule(hostRule)
        .addRule(applicationRule)
        .build
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_creating_a_menu_command_to_execute_the_transformation"><a class="link" href="#_creating_a_menu_command_to_execute_the_transformation">3.2.2. Creating a menu command to execute the transformation</a></h4>
<div class="ulist">
<ul>
<li>
<p>Create UI plugin</p>
</li>
<li>
<p>Add dependencies:</p>
<div id="app-listing" class="listingblock">
<div class="title">MANIFEST.MF</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">org.eclipse.ui,
com.incquerylabs.course.cps.viatra.incr;bundle-version="0.1.0",
org.eclipse.viatra.examples.cps.traceability;bundle-version="0.1.0",
org.eclipse.viatra.query.runtime;bundle-version="1.2.0"</code></pre>
</div>
</div>
</li>
<li>
<p>Create handler implementations:</p>
<div id="app-listing" class="listingblock">
<div class="title">ToggleTransformationHandler.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java" data-lang="java">public class ToggleTransformationHandler extends AbstractHandler implements IHandler {

    ViatraQueryEngine engine;
    CPS2DeploymentTransformationViatra transformation;


    /* (non-Javadoc)
     * @see org.eclipse.core.commands.IHandler#execute(org.eclipse.core.commands.ExecutionEvent)
     */
    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        IStructuredSelection selection =
            (IStructuredSelection) HandlerUtil.getCurrentSelection(event);

        CPSToDeployment tracemodel =
            (CPSToDeployment) selection.getFirstElement();

        if(transformation == null) {
            if(engine == null) {
                try {
                    engine = ViatraQueryEngine.on(
                                new EMFScope(
                                    tracemodel.eResource()
                                                .getResourceSet()));
                    transformation =
                        new CPS2DeploymentTransformationViatra(tracemodel,
                                                                engine);
                } catch (ViatraQueryException e) {
                    throw new ExecutionException(e.getMessage(), e);
                }
            }
        } else {
            transformation.dispose();
        }

        return null;
    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>Register handler in the context menu of "CPSToDeployment" elements</p>
<div id="app-listing" class="listingblock">
<div class="title">plugin.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;extension point="org.eclipse.ui.commands"&gt;
    &lt;command defaultHandler="com.incquerylabs.course.cps.viatra.incr.ui.ToggleTransformationHandler"
            id="com.incquerylabs.course.cps.viatra.incr.ui.command"
            name="Toggle Transformation"&gt;
    &lt;/command&gt;
&lt;/extension&gt;
&lt;extension point="org.eclipse.ui.menus"&gt;
    &lt;menuContribution allPopups="false"
            locationURI="popup:org.eclipse.ui.popup.any?after=additions"&gt;
        &lt;command commandId="com.incquerylabs.course.cps.viatra.incr.ui.command"
                label="Toggle Incremental Transformation"
                style="push"&gt;
            &lt;visibleWhen checkEnabled="false"&gt;
                &lt;with variable="selection"&gt;
                    &lt;count value="1"&gt;
                    &lt;/count&gt;
                    &lt;iterate&gt;
                        &lt;adapt type="org.eclipse.viatra.examples.cps.traceability.CPSToDeployment"&gt;
                        &lt;/adapt&gt;
                    &lt;/iterate&gt;
                &lt;/with&gt;
            &lt;/visibleWhen&gt;
        &lt;/command&gt;
    &lt;/menuContribution&gt;
&lt;/extension&gt;</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_executing_the_transformation"><a class="link" href="#_executing_the_transformation">3.2.3. Executing the transformation</a></h4>
<div class="ulist">
<ul>
<li>
<p>Launch runtime eclipse</p>
</li>
<li>
<p>Create a generic resource project</p>
</li>
<li>
<p>Copy a <code>.cyberphysicalsystem</code> resource in it</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example1.png" alt="viatraIncr example1">
</div>
<div class="title">Figure 15. Project with a .cyberphysicalsystem resource</div>
</div>
</li>
<li>
<p>Create an empty Deployment model</p>
<div class="ulist">
<ul>
<li>
<p>Root element shall be Deployment</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example2.png" alt="viatraIncr example2">
</div>
<div class="title">Figure 16. New Deployment Model</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Create a Traceability model</p>
<div class="ulist">
<ul>
<li>
<p>Root element shall be "CPS To Deployment"</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example3.png" alt="viatraIncr example3">
</div>
<div class="title">Figure 17. New Traceability Model</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>In the Traceability editor, load both CPS and Deployment models with "Load Resources.." in the context menu</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example4.png" alt="viatraIncr example4">
</div>
<div class="title">Figure 18. Load necessary resources into the Traceability Model</div>
</div>
</li>
<li>
<p>Set CPS and Deployment references of traceability model in the properties view</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example5.png" alt="viatraIncr example5">
</div>
<div class="title">Figure 19. Set the references of the Traceability Model</div>
</div>
</li>
<li>
<p>Toggle transformation using the created command (on the context menu of the Traceability model root)</p>
<div class="imageblock">
<div class="content">
<img src="images/screenshots/viatraIncr_example6.png" alt="viatraIncr example6">
</div>
<div class="title">Figure 20. Toggle transformation in the context menu</div>
</div>
</li>
<li>
<p>Initial activation done on first modification of the input model, e.g. create a new HostType</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_references_3"><a class="link" href="#_references_3">3.2.4. References</a></h4>
<div class="ulist">
<ul>
<li>
<p>VIATRA Transformation API: <a href="https://wiki.eclipse.org/VIATRA/Transformation/Transformation_API" class="bare">https://wiki.eclipse.org/VIATRA/Transformation/Transformation_API</a></p>
</li>
<li>
<p>Further transformation examples: <a href="https://wiki.eclipse.org/VIATRA/Transformation/Examples" class="bare">https://wiki.eclipse.org/VIATRA/Transformation/Examples</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>